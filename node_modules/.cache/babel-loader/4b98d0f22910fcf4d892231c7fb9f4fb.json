{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n_export(exports, {\n  MenuCore: function MenuCore() {\n    return _MenuCore;\n  },\n  default: function _default() {\n    return _default2;\n  }\n});\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDomInteractions = require(\"@floating-ui/react-dom-interactions\");\nvar _deepmerge = _interopRequireDefault(require(\"deepmerge\"));\nvar _theme = require(\"../../context/theme\");\nvar _menuContext = require(\"./MenuContext\");\nvar _menu = require(\"../../types/components/menu\");\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _MenuCore = _react.default.forwardRef(function (param, ref) {\n  var open = param.open,\n    handler = param.handler,\n    placement = param.placement,\n    offset = param.offset,\n    dismiss = param.dismiss,\n    animate = param.animate,\n    lockScroll = param.lockScroll,\n    children = param.children;\n  var menu = (0, _theme.useTheme)().menu;\n  var defaultProps = menu.defaultProps;\n  var ref1 = _slicedToArray(_react.default.useState(false), 2),\n    internalOpen = ref1[0],\n    setInternalOpen = ref1[1];\n  open = open !== null && open !== void 0 ? open : internalOpen;\n  handler = handler !== null && handler !== void 0 ? handler : setInternalOpen;\n  placement = placement !== null && placement !== void 0 ? placement : defaultProps.placement;\n  offset = offset !== null && offset !== void 0 ? offset : defaultProps.offset;\n  dismiss = dismiss !== null && dismiss !== void 0 ? dismiss : defaultProps.dismiss;\n  animate = animate !== null && animate !== void 0 ? animate : defaultProps.animate;\n  lockScroll = lockScroll !== null && lockScroll !== void 0 ? lockScroll : defaultProps.lockScroll;\n  var animation = {\n    unmount: {\n      opacity: 0,\n      transformOrigin: \"top\",\n      transform: \"scale(0.95)\",\n      transition: {\n        duration: .2,\n        times: [.4, 0, .2, 1]\n      }\n    },\n    mount: {\n      opacity: 1,\n      transformOrigin: \"top\",\n      transform: \"scale(1)\",\n      transition: {\n        duration: .2,\n        times: [.4, 0, .2, 1]\n      }\n    }\n  };\n  var appliedAnimation = (0, _deepmerge.default)(animation, animate);\n  var ref2 = _slicedToArray(_react.default.useState(null), 2),\n    activeIndex = ref2[0],\n    setActiveIndex = ref2[1];\n  var listItemsRef = _react.default.useRef([]);\n  var listContentRef = _react.default.useRef(_react.default.Children.map(children, function (child) {\n    return _react.default.isValidElement(child) ? child.props.children : null;\n  }));\n  var tree = (0, _reactDomInteractions.useFloatingTree)();\n  var nodeId = (0, _reactDomInteractions.useFloatingNodeId)();\n  var parentId = (0, _reactDomInteractions.useFloatingParentNodeId)();\n  var nested = parentId != null;\n  var ref3 = (0, _reactDomInteractions.useFloating)({\n      open: open,\n      onOpenChange: handler,\n      middleware: [(0, _reactDomInteractions.offset)(offset), (0, _reactDomInteractions.flip)(), (0, _reactDomInteractions.shift)()],\n      placement: placement,\n      nodeId: nodeId\n    }),\n    x = ref3.x,\n    y = ref3.y,\n    reference = ref3.reference,\n    floating = ref3.floating,\n    strategy = ref3.strategy,\n    refs = ref3.refs,\n    update = ref3.update,\n    context = ref3.context;\n  var ref4 = (0, _reactDomInteractions.useInteractions)([(0, _reactDomInteractions.useHover)(context, {\n      handleClose: (0, _reactDomInteractions.safePolygon)(),\n      enabled: nested\n    }), (0, _reactDomInteractions.useClick)(context), (0, _reactDomInteractions.useRole)(context, {\n      role: \"menu\"\n    }), (0, _reactDomInteractions.useDismiss)(context, dismiss), (0, _reactDomInteractions.useListNavigation)(context, {\n      listRef: listItemsRef,\n      activeIndex: activeIndex,\n      nested: nested,\n      onNavigate: setActiveIndex\n    }), (0, _reactDomInteractions.useTypeahead)(context, {\n      listRef: listContentRef,\n      onMatch: open ? setActiveIndex : undefined,\n      activeIndex: activeIndex\n    })]),\n    getReferenceProps = ref4.getReferenceProps,\n    getFloatingProps = ref4.getFloatingProps,\n    getItemProps = ref4.getItemProps;\n  _react.default.useEffect(function () {\n    if (open && refs.reference.current && refs.floating.current) {\n      return (0, _reactDomInteractions.autoUpdate)(refs.reference.current, refs.floating.current, update);\n    }\n  }, [open, nested, update, refs.reference, refs.floating]);\n  _react.default.useEffect(function () {\n    var onTreeOpenChange = function onTreeOpenChange(param) {\n      var openElement = param.openElement,\n        referenceElement = param.referenceElement,\n        parentElementId = param.parentElementId;\n      if (parentElementId !== nodeId) {\n        return;\n      }\n      listItemsRef.current.forEach(function (item) {\n        if (item && item !== referenceElement) {\n          item.style.pointerEvents = openElement ? \"none\" : \"\";\n        }\n      });\n    };\n    tree.events.on(\"openChange\", onTreeOpenChange);\n    return function () {\n      tree.events.off(\"openChange\", onTreeOpenChange);\n    };\n  }, [nodeId, tree.events, refs.reference, refs.floating]);\n  _react.default.useEffect(function () {\n    tree === null || tree === void 0 ? void 0 : tree.events.emit(\"openChange\", {\n      open: open,\n      parentId: parentId,\n      reference: refs.reference.current\n    });\n  }, [tree, open, parentId, refs.reference]);\n  var contextValue = _react.default.useMemo(function () {\n    return {\n      open: open,\n      handler: handler,\n      setInternalOpen: setInternalOpen,\n      strategy: strategy,\n      x: x,\n      y: y,\n      reference: reference,\n      floating: floating,\n      listItemsRef: listItemsRef,\n      getReferenceProps: getReferenceProps,\n      getFloatingProps: getFloatingProps,\n      getItemProps: getItemProps,\n      appliedAnimation: appliedAnimation,\n      lockScroll: lockScroll,\n      context: context\n    };\n  }, [open, handler, setInternalOpen, strategy, x, y, reference, floating, getReferenceProps, getFloatingProps, getItemProps, appliedAnimation, lockScroll, context]);\n  return _react.default.createElement(_menuContext.MenuContextProvider, {\n    value: contextValue\n  }, _react.default.createElement(_reactDomInteractions.FloatingNode, {\n    id: nodeId\n  }, children));\n});\n_MenuCore.propTypes = {\n  open: _menu.propTypesOpen,\n  handler: _menu.propTypesHandler,\n  placement: _propTypes.default.oneOf(_menu.propTypesPlacement),\n  offset: _menu.propTypesOffset,\n  dismiss: _menu.propTypesDismiss,\n  animate: _menu.propTypesAnimate,\n  lockScroll: _menu.propTypesLockScroll,\n  children: _menu.propTypesChildren\n};\n_MenuCore.displayName = \"MaterialTailwind.MenuCore\";\nvar _default2 = _MenuCore;","map":null,"metadata":{},"sourceType":"script"}