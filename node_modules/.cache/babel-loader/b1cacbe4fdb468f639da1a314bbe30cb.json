{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n_export(exports, {\n  TabsContext: function TabsContext() {\n    return _TabsContext;\n  },\n  useTabs: function useTabs() {\n    return _useTabs;\n  },\n  TabsContextProvider: function TabsContextProvider() {\n    return _TabsContextProvider;\n  },\n  setId: function setId() {\n    return _setId;\n  },\n  setActive: function setActive() {\n    return _setActive;\n  },\n  setAnimation: function setAnimation() {\n    return _setAnimation;\n  },\n  setIndicator: function setIndicator() {\n    return _setIndicator;\n  }\n});\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _tabs = require(\"../../types/components/tabs\");\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpreadProps(target, source) {\n  source = source != null ? source : {};\n  if (Object.getOwnPropertyDescriptors) {\n    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n  } else {\n    ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"SET_ID\":\n      {\n        return _objectSpreadProps(_objectSpread({}, state), {\n          id: action.value\n        });\n      }\n    case \"SET_ACTIVE\":\n      {\n        return _objectSpreadProps(_objectSpread({}, state), {\n          active: action.value\n        });\n      }\n    case \"SET_ANIMATION\":\n      {\n        return _objectSpreadProps(_objectSpread({}, state), {\n          appliedAnimation: action.value\n        });\n      }\n    case \"SET_INDICATOR\":\n      {\n        return _objectSpreadProps(_objectSpread({}, state), {\n          indicatorProps: action.value\n        });\n      }\n    default:\n      {\n        throw new Error(\"Unhandled action type: \".concat(action.type));\n      }\n  }\n}\nvar _TabsContext = _react.default.createContext(null);\n_TabsContext.displayName = \"MaterialTailwind.TabsContext\";\nfunction _useTabs() {\n  var context = _react.default.useContext(_TabsContext);\n  if (!context) {\n    throw new Error(\"useTabs() must be used within a Tabs. It happens when you use TabsHeader, TabsBody, Tab or TabPanel outside the Tabs component.\");\n  }\n  return context;\n}\nvar _TabsContextProvider = function _TabsContextProvider(param) {\n  var id = param.id,\n    value = param.value,\n    children = param.children;\n  var initialState = _react.default.useMemo(function () {\n    return {\n      id: id !== null && id !== void 0 ? id : \"indicator\",\n      active: value,\n      appliedAnimation: {\n        unmount: {},\n        mount: {}\n      },\n      indicatorProps: undefined\n    };\n  }, [id, value]);\n  var ref = _slicedToArray(_react.default.useReducer(reducer, initialState), 2),\n    state = ref[0],\n    dispatch = ref[1];\n  var contextValue = _react.default.useMemo(function () {\n    return {\n      state: state,\n      dispatch: dispatch\n    };\n  }, [state]);\n  return _react.default.createElement(_TabsContext.Provider, {\n    value: contextValue\n  }, children);\n};\nvar _setId = function _setId(dispatch, value) {\n  return dispatch({\n    type: \"SET_ID\",\n    value: value\n  });\n};\nvar _setActive = function _setActive(dispatch, value) {\n  return dispatch({\n    type: \"SET_ACTIVE\",\n    value: value\n  });\n};\nvar _setAnimation = function _setAnimation(dispatch, value) {\n  return dispatch({\n    type: \"SET_ANIMATION\",\n    value: value\n  });\n};\nvar _setIndicator = function _setIndicator(dispatch, value) {\n  return dispatch({\n    type: \"SET_INDICATOR\",\n    value: value\n  });\n};\n_TabsContextProvider.propTypes = {\n  id: _tabs.propTypesId,\n  value: _tabs.propTypesValue,\n  children: _tabs.propTypesChildren\n};\n_TabsContextProvider.displayName = \"MaterialTailwind.TabsContextProvider\";","map":null,"metadata":{},"sourceType":"script"}